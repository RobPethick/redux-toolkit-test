{"version":3,"sources":["app/hooks.ts","features/filters/filterSlice.ts","features/bookingGrid/bookingGridSlice.ts","features/filters/SpecialismSelector.tsx","features/filters/AppointmentTypeSelector.tsx","features/filters/AppointmentMediumSelector.tsx","features/filters/Filters.tsx","features/bookingGrid/Counsellor.tsx","features/bookingGrid/BookingGrid.tsx","App.tsx","app/store.ts","serviceWorker.ts","index.tsx"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","filterSlice","createSlice","name","initialState","date","specialisms","appointment_mediums","appointment_types","reducers","setDateFilter","state","action","payload","setSpecialismsFilter","setAppointmentTypesFilter","setAppointmentMediumsFilter","actions","selectDateFilter","filter","selectSelectedSpecialisms","selectSelectedAppointmentTypes","selectSelectedAppointmentMediums","bookingGridSlice","availabilities","counsellors","importAvailabilities","importCounsellors","selectCounsellors","bookingGrid","selectCurrentAvailabilities","createSelector","selectedDate","DateTime","fromISO","mapObjIndexed","array","filteredAvailabilities","availability","hasSame","datetime","sortedAvailabilities","sortBy","a","uniqBy","selectFilteredCounsellors","currentAvailabilities","filteredSpecialisms","filteredAppointmentTypes","fitleredAppointmentMediums","map","c","id","where","length","s","every","fs","includes","selectAvailableSpecialisms","uniq","flatMap","selectAvailableAppointmentTypes","selectAvailableAppointmentMediums","SpecialismSelector","availableSpecialisms","selectedSpecialisms","dispatch","FormControl","sx","m","width","InputLabel","Select","value","onChange","target","autoWidth","multiple","label","specialism","MenuItem","AppointmentTypeSelector","availableAppointmentTypes","selectedAppointmentTypes","AppointmentType","AppointmentMediumSelector","availableAppointmentMediums","selectedAppointmentMediums","AppointmentMedium","Filters","dateValue","MobileDatePicker","inputFormat","event","renderInput","params","TextField","Counsellor","counsellor","Accordion","AccordionSummary","expandIcon","ExpandMore","Typography","firstName","lastName","AccordionDetails","join","ButtonGroup","Button","toFormat","BookingGrid","availableCounsellors","App","ActionTypes","className","store","configureStore","reducer","filterReducer","bookingGridReducer","Boolean","window","location","hostname","match","CounsellorData","AvailabilityData","ReactDOM","render","StrictMode","LocalizationProvider","dateAdapter","DateAdapter","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.4ead54d2.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../../app/store';\n\nexport interface FilterState {\n  date: string;\n  specialisms: string[];\n  appointment_mediums: string[];\n  appointment_types: string[];\n}\n\nconst initialState: FilterState = {\n  date: '2021-07-25T00:00:00.000Z',\n  specialisms: [],\n  appointment_mediums: [],\n  appointment_types: [],\n};\n\n\nexport const filterSlice = createSlice({\n  name: 'filter',\n  initialState,\n  reducers: {\n    setDateFilter: (state, action: PayloadAction<string | null>) => {\n      if (action.payload) {\n        state.date = action.payload;\n      }\n    },\n    setSpecialismsFilter: (state, action: PayloadAction<string[]>) => {\n      state.specialisms = action.payload;\n    },\n    setAppointmentTypesFilter: (state, action: PayloadAction<string[]>) => {\n      state.appointment_types = action.payload;\n    },\n    setAppointmentMediumsFilter: (state, action: PayloadAction<string[]>) => {\n      state.appointment_mediums = action.payload;\n    },\n  },\n});\n\nexport const { setDateFilter, setSpecialismsFilter, setAppointmentTypesFilter, setAppointmentMediumsFilter } = filterSlice.actions;\n\nexport const selectDateFilter = (state: RootState) => state.filter.date;\nexport const selectSelectedSpecialisms = (state: RootState) => state.filter.specialisms;\nexport const selectSelectedAppointmentTypes = (state: RootState) => state.filter.appointment_types;\nexport const selectSelectedAppointmentMediums = (state: RootState) => state.filter.appointment_mediums;\n\n\nexport default filterSlice.reducer;\n","import { createSelector, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { DateTime } from 'luxon';\nimport { mapObjIndexed, sortBy, uniq, uniqBy, where } from 'ramda';\nimport { RootState } from '../../app/store';\nimport { selectDateFilter, selectSelectedAppointmentMediums, selectSelectedAppointmentTypes, selectSelectedSpecialisms } from '../filters/filterSlice';\n\nexport interface Counsellor {\n  id: string,\n  firstName: string,\n  lastName: string,\n  appointment_types: string[],\n  appointment_mediums: string[],\n  specialisms: string[]\n}\n\nexport interface Availability {\n  id: string;\n  datetime: string;\n}\n\nexport interface BookingGrid {\n  availabilities: { [counsellorId in string]: Availability[] };\n  counsellors: Counsellor[];\n}\n\nconst initialState: BookingGrid = {\n  availabilities: {},\n  counsellors: [],\n};\n\n\nexport const bookingGridSlice = createSlice({\n  name: 'filter',\n  initialState,\n  reducers: {\n    importAvailabilities: (state, action: PayloadAction<BookingGrid['availabilities']>) => {\n      state.availabilities = action.payload;\n    },\n    importCounsellors: (state, action: PayloadAction<Counsellor[]>) => {\n      state.counsellors = action.payload;\n    },\n  },\n});\n\nexport const { importAvailabilities, importCounsellors } = bookingGridSlice.actions;\n\nexport const selectAvailabilities = (state: RootState) => state.bookingGrid.availabilities;\nexport const selectCounsellors = (state: RootState) => state.bookingGrid.counsellors;\nexport const selectCurrentAvailabilities = createSelector(selectAvailabilities, selectDateFilter,\n  (availabilities, date) => {\n    const selectedDate = DateTime.fromISO(date);\n    return mapObjIndexed((array) => {\n       const filteredAvailabilities = array.filter((availability) => selectedDate.hasSame(DateTime.fromISO(availability.datetime), 'day'))\n       const sortedAvailabilities = sortBy((a) => a.datetime, filteredAvailabilities);\n       return uniqBy((a) => a.datetime, sortedAvailabilities);\n    }, availabilities);\n  });\n\nexport const selectFilteredCounsellors = createSelector(\n  selectCurrentAvailabilities,\n  selectCounsellors,\n  selectSelectedSpecialisms,\n  selectSelectedAppointmentTypes,\n  selectSelectedAppointmentMediums,\n  (currentAvailabilities, counsellors, filteredSpecialisms, filteredAppointmentTypes, fitleredAppointmentMediums) => {\n    return counsellors.map((c) => ({ ...c, availabilities: currentAvailabilities[c.id] ?? [] }))\n    .filter(where({\n      availabilities: (a: Availability[]) => a.length !== 0,\n      specialisms: (s: string[]) => filteredSpecialisms.length === 0 || filteredSpecialisms.every((fs) => s.includes(fs)),\n      appointment_types: (s: string[]) => filteredAppointmentTypes.length === 0 || filteredAppointmentTypes.every((fs) => s.includes(fs)),\n      appointment_mediums: (s: string[]) => fitleredAppointmentMediums.length === 0 || fitleredAppointmentMediums.every((fs) => s.includes(fs))\n    }))\n  }\n)\n\nexport const selectAvailableSpecialisms = createSelector(selectCounsellors, (counsellors) => uniq(counsellors.flatMap((c) => c.specialisms)));\nexport const selectAvailableAppointmentTypes = createSelector(selectCounsellors, (counsellors) => uniq(counsellors.flatMap((c) => c.appointment_types)));\nexport const selectAvailableAppointmentMediums = createSelector(selectCounsellors, (counsellors) => uniq(counsellors.flatMap((c) => c.appointment_mediums)));\n\n\n\nexport default bookingGridSlice.reducer;\n","import React from 'react';\n\nimport { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport { selectSelectedSpecialisms, setSpecialismsFilter } from './filterSlice';\nimport { FormControl, InputLabel, MenuItem, Select } from '@mui/material';\nimport { selectAvailableSpecialisms } from '../bookingGrid/bookingGridSlice';\n\nexport function SpecialismSelector() {\n  const availableSpecialisms = useAppSelector(selectAvailableSpecialisms);\n  const selectedSpecialisms = useAppSelector(selectSelectedSpecialisms);\n\n  const dispatch = useAppDispatch()\n  return (\n    <FormControl sx={{ m: 1, width: 300 }}>\n      <InputLabel>Specialisms</InputLabel>\n      <Select\n        value={selectedSpecialisms}\n        onChange={(selectedSpecialisms) => dispatch(setSpecialismsFilter(selectedSpecialisms.target.value as string[]))}\n        autoWidth\n        multiple\n        label=\"Specialisms\"\n      >\n        {\n          availableSpecialisms.map((specialism) => <MenuItem value={specialism}>{specialism}</MenuItem>)\n        }\n      </Select>\n    </FormControl>\n  );\n}\n","import React from 'react';\n\nimport { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport { selectSelectedAppointmentTypes, setAppointmentTypesFilter } from './filterSlice';\nimport { FormControl, InputLabel, MenuItem, Select } from '@mui/material';\nimport { selectAvailableAppointmentTypes } from '../bookingGrid/bookingGridSlice';\n\nexport function AppointmentTypeSelector() {\n  const availableAppointmentTypes = useAppSelector(selectAvailableAppointmentTypes);\n  const selectedAppointmentTypes = useAppSelector(selectSelectedAppointmentTypes);\n\n  const dispatch = useAppDispatch()\n  return (\n    <FormControl sx={{ m: 1, width: 150 }}>\n      <InputLabel>Appointment Types</InputLabel>\n      <Select\n        value={selectedAppointmentTypes}\n        onChange={(selectedAppointmentTypes) => dispatch(setAppointmentTypesFilter(selectedAppointmentTypes.target.value as string[]))}\n        autoWidth\n        multiple\n        label=\"Appointment Types\"\n      >\n        {\n          availableAppointmentTypes.map((AppointmentType) => <MenuItem value={AppointmentType}>{AppointmentType}</MenuItem>)\n        }\n      </Select>\n    </FormControl>\n  );\n}\n","import React from 'react';\n\nimport { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport { selectSelectedAppointmentMediums, setAppointmentMediumsFilter } from './filterSlice';\nimport { FormControl, InputLabel, MenuItem, Select } from '@mui/material';\nimport { selectAvailableAppointmentMediums } from '../bookingGrid/bookingGridSlice';\n\nexport function AppointmentMediumSelector() {\n  const availableAppointmentMediums = useAppSelector(selectAvailableAppointmentMediums);\n  const selectedAppointmentMediums = useAppSelector(selectSelectedAppointmentMediums);\n\n  const dispatch = useAppDispatch()\n  return (\n    <FormControl sx={{ m: 1, width: 200 }}>\n      <InputLabel>Appointment Mediums</InputLabel>\n      <Select\n        value={selectedAppointmentMediums}\n        onChange={(selectedAppointmentMediums) => dispatch(setAppointmentMediumsFilter(selectedAppointmentMediums.target.value as string[]))}\n        autoWidth\n        multiple\n        label=\"Appointment Mediums\"\n      >\n        {\n          availableAppointmentMediums.map((AppointmentMedium) => <MenuItem value={AppointmentMedium}>{AppointmentMedium}</MenuItem>)\n        }\n      </Select>\n    </FormControl>\n  );\n}\n","import React from 'react';\n\nimport { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport { selectDateFilter, setDateFilter } from './filterSlice';\nimport MobileDatePicker from '@mui/lab/MobileDatePicker';\nimport { FormControl, TextField } from '@mui/material';\nimport { SpecialismSelector } from './SpecialismSelector';\nimport { AppointmentTypeSelector } from './AppointmentTypeSelector';\nimport { AppointmentMediumSelector } from './AppointmentMediumSelector';\n\nexport function Filters() {\n  const dispatch = useAppDispatch();\n  const dateValue = useAppSelector(selectDateFilter)\n  return (\n    <div>\n      <FormControl sx={{ m: 1}}>\n        <MobileDatePicker\n          label=\"Date\"\n          inputFormat=\"dd/MM/yyyy\"\n          value={dateValue}\n          onChange={(event) => dispatch(setDateFilter(event))}\n          renderInput={(params) => <TextField {...params} />}\n        />\n      </FormControl>\n      <SpecialismSelector />\n      <AppointmentTypeSelector />\n      <AppointmentMediumSelector />\n    </div>\n  );\n}\n","\nimport { selectFilteredCounsellors } from './bookingGridSlice';\nimport { Accordion, AccordionSummary, AccordionDetails, Typography, ButtonGroup, Button } from '@mui/material';\nimport { ExpandMore } from '@mui/icons-material';\nimport { DateTime } from 'luxon';\n\nexport interface CounsellorProps {\n  counsellor: ReturnType<typeof selectFilteredCounsellors>[0]\n}\nexport function Counsellor({ counsellor }: CounsellorProps) {\n  return (\n    <Accordion>\n      <AccordionSummary\n        expandIcon={<ExpandMore />}\n      >\n        <Typography>{`${counsellor.firstName} ${counsellor.lastName}`}</Typography>\n      </AccordionSummary>\n      <AccordionDetails>\n        <Typography>\n          Appointment mediums: {counsellor.appointment_mediums.join(', ')}\n        </Typography>\n        <Typography>\n          Appointment types: {counsellor.appointment_types.join(', ')}\n        </Typography>\n        <Typography>\n          Specialisms: {counsellor.specialisms.join(', ')}\n        </Typography>\n        <ButtonGroup>\n          {counsellor.availabilities.map((availability) => <Button >{DateTime.fromISO(availability.datetime).toFormat('HH:mm')}</Button>)}\n        </ButtonGroup>\n      </AccordionDetails>\n    </Accordion>\n  );\n}\n","\nimport { useAppSelector } from '../../app/hooks';\nimport { selectFilteredCounsellors } from './bookingGridSlice';\nimport { Counsellor } from './Counsellor';\n\nexport function BookingGrid() {\n  const availableCounsellors = useAppSelector(selectFilteredCounsellors);\n  return (\n    <div>\n      {\n        availableCounsellors.map((counsellor) => <Counsellor counsellor={counsellor}/>)\n      }\n    </div>\n  );\n}\n","import React from 'react';\nimport { Filters } from './features/filters/Filters';\nimport './App.css';\nimport { BookingGrid } from './features/bookingGrid/BookingGrid';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Filters />\n      <BookingGrid />\n    </div>\n  );\n}\n\nexport default App;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport bookingGridReducer from '../features/bookingGrid/bookingGridSlice';\nimport filterReducer from '../features/filters/filterSlice';\n\nexport const store = configureStore({\n  reducer: {\n    filter: filterReducer,\n    bookingGrid: bookingGridReducer\n  },\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n\nexport enum ActionTypes {\n  IMPORT_AVAILABILITY = 'IMPORT_AVAILABILITY',\n  IMPORT_COUNSELLOR = 'IMPORT_COUNSELLOR',\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { ActionTypes, store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\nimport DateAdapter from '@mui/lab/AdapterLuxon';\nimport LocalizationProvider from '@mui/lab/LocalizationProvider';\nimport AvailabilityData from './data/availability-mock.json';\nimport CounsellorData from './data/counsellor-mock.json';\nimport { importAvailabilities, importCounsellors } from './features/bookingGrid/bookingGridSlice';\n\nstore.dispatch(importCounsellors(CounsellorData));\nstore.dispatch(importAvailabilities(AvailabilityData));\nReactDOM.render(\n  <React.StrictMode>\n    <LocalizationProvider dateAdapter={DateAdapter}>\n      <Provider store={store}>\n        <App />\n      </Provider>\n    </LocalizationProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}